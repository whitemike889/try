# For full annotated example, please visit
#   https://cloudes.visualstudio.com/CDPX/_wiki?pagePath=%2FHome%2FYAML-Format%2FAnnotated-Example

# The following section is a metadata section that describes what kind of environment this pipeline should be executing in. Some of the
# information is redundant and will be removed in a future version.
environment:
  host:
    os: 'linux'                                                         # used to verify at runtime that correct host pool is being used
    flavor: 'ubuntu'                                                    # not used and will be removed in future
    version: '16.04'                                                    # not used and will be removed in future
  runtime:
    provider: 'appcontainer'                                            # Currently only appcontainer is supported future will bring
                                                                        # oscontainer and virtualmachine
    image: 'microsoft/dotnet:2.1.301-sdk-alpine'                                   # This is the image that your pipeline will run in.
                                                                        # For (appcontainer), Docker Hub public Microsoft repository images
                                                                        # can be used.
                                                                        # Example microsoft/dotnet:1.1.1-sdk-nanoserver. Or the CDP team
                                                                        # vended and custom images can be used.
                                                                        # These are cdpxtest.azurecr.io/user/<user-image-name> or
                                                                        # cdpxtest.azurecr.io/samples/wsmobile (for now).
    source_mode: 'link' #source maybe crashes?                                                # 'copy' or 'link'. There is a known bug for npm and ruby on some of
                                                                        # our images that linked folder in container may cause errors on these
                                                                        # languages, for that case, use 'copy' here and pipeline will full
                                                                        # copy source into container from host before each step and full copy
                                                                        # out back to host after each step. It may be very slow if you have a
                                                                        # giant repository.

# The following is a metadata section that describes the versioning scheme and basic version datacenter to use. This data will be used to
# generate content in the .version folder for use by your custom versioning steps.
# In fact, in this sample, a file named .version\PipelineAssemblyInfo.cs will be generated that contains the following code (ignore the actual
# versions because those are dummy values).
#
# // This is a CDPX pipeline generated file
# using System.Reflection;
# [assembly: AssemblyVersion("1.0.060517.1000")]
# [assembly: AssemblyFileVersion("1.0.060517.1000")]
# [assembly: AssemblyInformationalVersion("1.0.060517.1000-test-31f791f1")]
#
# The key point is that this file is not checked in by CDPX. So, we check in a dummy file with similar content and add this file as a compile
# item with a link. When the code is built in CDPX, the file is first overwritten with actual version numbers. Thus, when the code compiles,
# the new version numbers are picked up.
#
# Obviously, this may not work for everyone. So, in addition to these template files, CDPX writes out several info files whose content is some
# part of the version number. Which part is hinted at by the name of the file.
# For example, package.semantic.info will contain patch semantic version number in the form 1.0.MMddyyrrrr-tag-commit.
version:
  name: 'MLS.Agent'                                                     # The uber name to attach to the artifacts generated by this pipeline.
                                                                        # Currently unused, but will be used in the future to refer to the 
                                                                        # artifacts as a group by name.
  major: 1                                                              # The major version number.
  minor: 0                                                              # The minor version number
  tag: 'alpha'                                                          # Tag to use for semantic versioning.
  system: 'buildrevision'                                                       # Versioning scheme to use.
                                                                        # patch         - 1.0.MMddyyrrrr will be generated
                                                                        # buildrevision - 1.0.MMddyy.rrrr will be generated.

# The following is an optional user defined stage. If the version numbers generated by the pipeline are not compatible with your pre-existing
# model, then you can customize your version number any way you want by executing any scripts in this stage. This is a logical organization;
# you can do this even in build stage but we will be adding support to make VSTS show the custom version number in the future.
# Eventually, network access will be limited or cut-off in this stage.
versioning:
  commands:                                                             # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
                                                                        # We are not doing anything here. In fact, we could have omitted the
                                                                        # versioning stage entirely.

# An optional user defined stage for performing any compilation, code generation etc.
# All files in the artifacts sections will be collected, saved off and signed.
# The signed files will be restored back to the original locations before the next stage is invoked.
# Eventually, network access will be limited or cut-off in this stage.
build:
  commands:

    - !!buildcommand
      name: '.cdpx/restore.sh'
      command: '.cdpx/restore.sh'
      fail_on_stderr: false

    - !!buildcommand
      name: '.cdpx/build.sh'
      command: '.cdpx/build.sh'
      fail_on_stderr: false
                                                                        
      artifacts:                                         
        - from: './express/ServiceLayout'
          to: 'ServiceLayout'
          include:
            - '**/*'        
        - from: '.'
          to: '.'
          include:
            - 'build.artifact.commit.sha'                                                  
        - from: './.cdpx'
          to: '.cdpx'
          include:
            - '**/*' 
                                                                        # We always preserve the root relative path for every matched file.
                                                                        # Sometimes that's OK and sometimes it's not. The from, to options
                                                                        # (both are optional and either of them can be used independently)
                                                                        # allow you to remap the folder from which articacts are picked up to
                                                                        # a different location. Think of this as a effectively doing a
                                                                        # robocopy /S C:\X\Y to D;\F.
# An optional user defined stage for performing packaging. This exists as a separate stage because some build processes do a
# compile-sign-package-sign model. For example, Windows based builds use this model. Linux builds typically follow a
# compile-hash-package-hash-sign hash model. For those folks, package may not need to exist as a separate step.
# Eventually, network access will be limited or cut-off in this stage.
package:
  commands:
    - !!dockerbuildcommand
      name: 'Build container'
      context_folder: './docker/'
      dockerfile_name: 'Dockerfile'
      repository_name: 'mls.agent'
      tag: '1.0.0alpha'                                                 # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
                                                                        # We are not doing anything here. In fact, we could have omitted the
                                                                        # package stage entirely.
            
# An optional user defined stage for running tests that need network access. Note that unit tests and others that do not need network access
# can be run in build or package stages itself. Any artifacts built in this stage will be separated out and will not be signed.
# However, we recommend that tests always be run in the test stage.
# Eventually, we may even skip test artifacts completely.

test:
  commands:
    - !!testcommand
      name: 'Test'
      command: '.cdpx/test.sh'
      fail_on_stderr: false 
      testresults:
        - title: 'Unit Tests'
          type: 'VSTest'
          include:
            - '**/*.trx'

                                                                        # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
#   - !!testcommand                                                     # We are going to run tests and collect back the test results for
#                                                                       # publishing
#     name: 'Test The Code'                                             # If your test run does not have a name, this will be used.
#     command: 'src\test.cmd'                                           # Script that runs tests.
#     testresults:                                                      # Sequence of entries indicating which test results files to collect.
#       - title: 'All Tests'                                            # Test run title. Used by VSTS.
#         configuration: 'Debug'                                        # Optional build configuration.
#         platform: 'x64'                                               # Optional build platform.
#         type: 'vstest'                                                # Test engine type. Used by VSTS. Supported values are JUnit, NUnit,
#                                                                       # VSTest and xUnit.
#         include:                                                      # Sequence of glob patterns indicating which test results file to
#                                                                       # associate with this test run.
#           - 'src\**\TestResults\**\*.trx'                             # Include all TRX files under any TestResults folder under the src
#                                                                       # folder.



# An optional, interim user defined stage for performing publishing of the build. Examples include, dropping the files to a network share,
# pushing packages to a package repository, uploading binaries to blob store etc. 
# Eventually, network access in this stage will be restricted to dev-feeds only for non-official builds. We may remove this stage for official
# builds. Teams should use VSRM or Ev2 to release.
publish:
  commands:                                                             # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
                                                                        # We are not doing anything here. In fact, we could have omitted the
                                                                        # publish stage entirely.

# An optional user defined stage for running any type of always-needed uber cleanup. This exists as a separate stage because some build
# processes acquire shared resources during some stages. In case the build is cancelled or aborted or fails, this stage is provided so that
# these resources can be unacquired. In particular, the commands in this stage are always run.
user_cleanup:
  commands:                                                             # This is a sequence of script files to be executed one after another
                                                                        # in the order they appear here.
                                                                        # We are not doing anything here. In fact, we could have omitted the
                                                                        # user_cleanup stage entirely.
